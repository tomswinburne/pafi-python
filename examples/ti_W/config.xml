<!-- Which parameters to scan.
If ReactionCoordinate and Temperature are not present an error will be raised
The iteration sequence follows the order in this file,

i.e. a python equivalent of this example would be

for T in Temperature:
  for r in ReactionCoordinate:
    for l in Lambda:
      /* do simulation */

If Temperature and ReactionCoordinate are not present an error will be raised

-->
<Parameters>
  <!-- Format is Min, Max, Number of steps -->
  <Lambda>0.1 1.0 5</Lambda>
  <ReactionCoordinate>0.0 0.5 2</ReactionCoordinate>
  <Temperature>100. 500. 2</Temperature>
</Parameters>

<Setup>


  <!-- MUST INCLUDE trailing forward slash -->
  <DumpFolder>./output/</DumpFolder>

  <!-- Global random number seed used to set worker seeds.
  If all parameters are left unchanged, simulation results should be
  identical up to MD integration error for the same GlobalSeed
  -->
  <GlobalSeed>137</GlobalSeed>

  <!-- do we dump deviation files? can be large -->
  <WriteDev>0</WriteDev>

  <!--If FreshSeed==1, a new seed is set for each sampling run.
    With FreshSeed==0, a worker uses the same seed for all planes.
    This may reduce error in stochastic gradients... -->
  <FreshSeed>0</FreshSeed>


  <!-- We require nprocs % CoresPerWorker==0 -->
  <CoresPerWorker> 2 </CoresPerWorker>

  <!-- Number of samples per plane per worker -->
  <nRepeats> 1 </nRepeats>

  <!-- Data gathering steps -->
  <SampleSteps> 100 </SampleSteps>

  <!-- Steps for thermalization -->
  <ThermSteps> 100 </ThermSteps>

  <!-- Max steps for optional in-plane minimizations (see below) -->
  <MinSteps> 10000 </MinSteps>

  <!--
    RELATIVE thermal expansion coefficients along X,Y,Z directions of simulation-
    X -> X *(1 + LinearThermalExpansionX*T + QuadraticThermalExpansionX*T^2)
    Y -> X *(1 + LinearThermalExpansionY*T + QuadraticThermalExpansionY*T^2)
    Z -> X *(1 + LinearThermalExpansionZ*T + QuadraticThermalExpansionZ*T^2)
  -->
  <LinearThermalExpansionX>0.0</LinearThermalExpansionX>
  <QuadraticThermalExpansionX>0.0</QuadraticThermalExpansionX>
  <LinearThermalExpansionY>0.0</LinearThermalExpansionY>
  <QuadraticThermalExpansionY>0.0</QuadraticThermalExpansionY>
  <LinearThermalExpansionZ>0.0</LinearThermalExpansionZ>
  <QuadraticThermalExpansionZ>0.0</QuadraticThermalExpansionZ>


  <!-- perform overdamped/Brownian or Langevin dynamics on hyperplane -->
  <OverDamped> 1 </OverDamped>

  <!--
  Friction parameter as used by MD engine (here LAMMPS : 1/strength)
  Typical 'units metal' value : 0.1 == 100 time steps decay time
  If OverDamped=1, we set a strong friction i.e. < 0.1, e.g. 0.05
  -->
  <Friction> 0.05 </Friction>

  <!-- 0/1 Output LAMMPS logfiles for error checking purposes -->
  <LogLammps> 0 </LogLammps>

  <!--
   0 : (Default) Output time-and-ensemble averaged in-plane deviation from reference pathway. Can indicate finite temperature path but will have sampling noise
   1 : Output ensemble averaged in-plane deviation following in-plane minimization post-run. No noise but will lose some/all features of path
  -->
  <PostDump> 0 </PostDump>

  <!--
  Perform an in-plane minimization before thermalization/sampling.
  If pathway is a well-converged NEB/MEP this should not produce any change
  -->
  <PreMin> 1 </PreMin>

  <!-- If == 0 ignore ReactionCoordinate parameter,
  sample only at provided pathway configurations. Test feature -->
  <Rediscretize>1</Rediscretize>

  <!-- Use geometric distance for MEP coordinate (Default: 1) -->
  <RealMEPDist>1</RealMEPDist>

  <!-- Maximum Atomic Displacement between local in-plane minima
  before and after sampling run which can still be considered "in basin"
  Check for shallow metastability on hyperplane
  -->
  <MaxJump> 0.4 </MaxJump>

  <!-- Resample a batch if less than this proportion are "in-basin" -->
  <ReSampleThresh> 0.8 </ReSampleThresh>

  <!-- How many resample attempts -->
  <maxExtraRepeats> 1 </maxExtraRepeats>

  <!--
  Sequential list of pathway configurations,
  produced from e.g. a NEB configuration.
  Loaded via LAMMPS read_data (see Scripts/Input below)
  -->
  <PathwayConfigurations>
    ../systems/EAM-SNAP-VAC-W/image_0.dat
    ../systems/EAM-SNAP-VAC-W/image_1.dat
    ../systems/EAM-SNAP-VAC-W/image_2.dat
    ../systems/EAM-SNAP-VAC-W/image_3.dat
    ../systems/EAM-SNAP-VAC-W/image_4.dat
    ../systems/EAM-SNAP-VAC-W/image_5.dat
    ../systems/EAM-SNAP-VAC-W/image_6.dat
    ../systems/EAM-SNAP-VAC-W/image_7.dat
    ../systems/EAM-SNAP-VAC-W/image_8.dat
  </PathwayConfigurations>
</Setup>

<Scripts>
  <!-- LAMMPS script to read in the first pathway
      configuration and load the potential
  -->
  <Input>
    units metal
    atom_style atomic
    atom_modify map array sort 0 0.0
    neigh_modify every 2 delay 10 check yes page 1000000 one 100000
    read_data  ../systems/EAM-SNAP-VAC-W/image_0.dat
    pair_style    hybrid/overlay eam/fs snap
    pair_coeff * * eam/fs ../systems/EAM-SNAP-VAC-W/W.eam.fs W
    pair_coeff * * snap ../systems/EAM-SNAP-VAC-W/W.snapcoeff ../systems/EAM-SNAP-VAC-W/W.snapparams W
    run 0
  </Input>
</Scripts>

<Setup>
  <!--
  list names of global fixes extracted during sampling- name, size
  these should be relfected in <Pre/PostSample>
  -->
  <SampleFixes>dV 1</SampleFixes>
</Setup>

<Scripts>
  <!-- Apply any fixes before thermalization/sampling -->
  <PreRun>
    variable l1 equal 1.0-%Lambda%
    variable l2 equal 0.0+%Lambda%
    run 0
    fix escale1 all adapt 1 pair eam/fs scale * * v_l1
    fix escale2 all adapt 1 pair snap scale * * v_l2
    run 0
    compute V_1 all pair eam/fs
    compute V_2 all pair snap
    variable epsilon equal 0.0000001
    variable V_1 equal (c_V_1/(${l1} + ${epsilon}))
    variable V_2 equal (c_V_2/(${l2} + ${epsilon}))
    variable dV equal ${V_2}-${V_1}
  </PreRun>

  <!-- fixes only applied for sampling run.
    SEE "SampleFixes" TAG IN "Setup" -->
  <PreSample>
    fix dV all ave/time 1 %SampleSteps% %SampleSteps% v_dV
  </PreSample>

  <!-- Disable after sampling -->
  <PostSample>
    unfix dV
  </PostSample>

  <!-- Turn off these same fixes after each sampling run -->
  <PostRun>
    variable dV delete
    uncompute V_1
    uncompute V_2
    unfix escale1
    unfix escale2
  </PostRun>

</Scripts>
